
module FileBuilder
	def self.included(base)
		base.extend(ClassMethods)
	end
	#*********************************************************************************************************************************
	def populate_values_from_baseline(fileName)
		baselineFile = File.open(fileName, 'r')
		values = baselineFile.readlines[0].chomp.split('|') if self.class.name.match(/Header/)
		values = baselineFile.readlines[1].chomp.split('|') if self.class.name.match(/Detail/)
		
		setter_methods_to_call = (self.methods - self.class.methods).grep(/=/)
		setter_methods_to_call.each_with_index do |method, i|
			self.send(method, values[i])
		end
		baselineFile.close()
	end
	#*********************************************************************************************************************************	
	def set(target, value)
		self.send("#{target.to_s.delete('@')}=", value)
	end
	#*********************************************************************************************************************************	
	def get(target)
		self.send("#{target.to_s.delete('@')}")
	end
	#*********************************************************************************************************************************
	def comb_values()
		values = []
		self.instance_variables.each do |var|
			values << self.get(var)
		end
		return values
	end
	#*********************************************************************************************************************************
	def generate_EFN(mid)
		return "92750#{mid}#{rand(99999999).to_s.rjust(8, '0')}"
	end
	#*********************************************************************************************************************************
	#Filename Generator
	def generate_file_name(klass, mail_class, date, time, *trim)
		if klass == Manifest
			if trim[0] == 'r'
				return "#{$targetPath}/Generated EVS Files/autogenerated_#{mail_class}_#{date}_RateTest"
			else
				return "#{$targetPath}/Generated EVS Files/autogenerated_#{mail_class}_#{date}#{time}"
			end
		#Include other file types and their file naming conventions.
		end
	end
	#*********************************************************************************************************************************
	def validate(value, &validation)
		while not validation.call(value)
			puts "#{value} is not a valid entry.  Please re-enter a valid value:"
			value = gets.chomp
		end
		return value
	end
	#*********************************************************************************************************************************
	def test_output()
		output = ''
		self.instance_variables.each do |var|
			output = output + (self.send(var.to_s.delete('@')) || '') + '|'
		end
		return output
	end
	#*********************************************************************************************************************************
	def build_raw()
		header = self.header.test_output
		details = []
		self.details.each do |detail|
			details << detail.test_output
		end
		manifest = File.open("#{self.fileName}.raw", 'w')
		manifest.write(header)
		details.each do |detail|
			manifest.write("\n")
			manifest.write(detail)
		end
		manifest.close()
	end
	#*********************************************************************************************************************************
	def build_cew()
		cewFields = [self.mailer.mid, self.header.electronic_file_number[14..21], self.date, self.time, self.originZIP, self.date, self.size.to_s, '0', self.size.to_s, self.details.size.to_s, ''] 
		cew = File.open("#{self.fileName}.cew", 'w')
		cewFields.each do |val|
			cew.write(val + ',')
		end
		cew.close()
	end
	#*********************************************************************************************************************************
	def build_sem()
		sem = File.open("#{self.fileName}.sem", 'w')
		sem.close()
	end
	#*********************************************************************************************************************************		
	def exit()
		puts "Press any key to exit the program."
		prompt()
		gets()
	end
	#*********************************************************************************************************************************
	def prompt()
		print "> "
	end
	#*********************************************************************************************************************************
	module ClassMethods
		def create_fields_using(fileName)
			file = File.open(fileName, 'r')
			fields = file.readline.chomp.split(',')
			fields.map! {|field| format_instance_variable_name(field)}
			self.class_eval do
				fields.each do |fieldAsVariable|
					define_method "#{fieldAsVariable}=" do |value|  #Define setter method for each field pulled from reference file (.csv)
						instance_variable_set("@#{fieldAsVariable}", value)
					end
					define_method "#{fieldAsVariable}" do
						instance_variable_get("@#{fieldAsVariable}")
					end
				end
				file.close()
				return fields
			end
		end
	#*********************************************************************************************************************************
		def format_instance_variable_name(name)
			name.downcase.gsub(' ', '_').gsub('-', '_').gsub('+', 'plus').delete('()')
		end
	#*********************************************************************************************************************************
=begin
	#*********************************************************************************************************************************
	#Handler for Sample Building
	def sampleGen()
		puts "Enter 's' to generate a sample for this file.  (Anything else to continue without building a sample.)"
		prompt
		input = gets.downcase.chomp
		if input == 's'
			if @domClasses.include?(@mailClass) #Allows for selection of valid sample types for Domestic Mail Classes
				puts "What type of sample file? 'i' for IMD, 'pass' for PASS, 'pos' for POS, or 's' for STATS."
				prompt
				sType = gets.downcase.chomp
				while not ['i', 'pass', 'pos', 's'].include?(sType)
					puts "#{sType} is not a valid selection.  Please enter 'i' for IMD, 'pass' for PASS, 'pos' for POS, or 's' for STATS."
					prompt
					sType = gets.downcase.chomp
				end
				case sType #Sample Type
				when 'i' #IMD
					buildIMD()
				when 'pass' #PASS
					buildPASS()
				when 'pos' #POS
					buildPOS()
				when 's' #STATS
					buildSTATS()
				end
			elsif @intClasses.include?(@mailClass) #Allows for selection of valid sample types for International Mail Classes
				puts "What type of sample file? 'i' for IMD or 's' for STATS."
				prompt
				sType = gets.downcase.chomp
				while not ['i', 'pass', 'pos', 's'].include?(sType)
					puts "#{sType} is not a valid selection.  Please enter 'i' for IMD, 'pass' for PASS, 'pos' for POS, or 's' for STATS."
					prompt
					sType = gets.downcase.chomp
				end
				case sType #Sample Type
				when 'i' #IMD
					buildIMD()
				when 's' #STATS
					buildSTATS()
				end
			end
		end
	end
	#*********************************************************************************************************************************
	#Re-format weight for STATS Files
	def statsWeight(value)
		pounds = value[2, 3] #Pulls the 3rd (X), 4th (Y) and 5th (Z) digit from the format 00XYZdddd where 'd' is the decimal portion of the eVS weight convention
		ounces = ((('0.' + value[5, 4]).to_f)*16).round(1).to_s
		ounces = ounces.to_f.round().to_s.rjust(3, ' ') if ounces.size > 3
		return pounds, ounces
	end
	#*********************************************************************************************************************************
	#Re-format dimensions for STATS Files
	def statsSize(value)
		wholeNum = value[0,3] #Pulls the whole number portion of the eVS dimension/size convention
		decimal = value[3, 2] #Pulls the decimal portion
		return "#{wholeNum}.#{decimal}".to_f.round.to_s
	end
	#*********************************************************************************************************************************
	#Calculates STATS Value for Mail Class
	def statsClass(value)
		if value == 'FC'
			return '10' #Code for First Class Mail
		elsif value == 'PM' or value == 'CM'
			return '20' #Code for Priority Mail
		elsif value == 'S2'
			return '40' #Code for Standard
		elsif value == 'SA'
			return '90' #Code for Standard Non-Profit
		elsif value == 'CP'
			return '7G' #Code for Priority Mail International
		elsif value == 'LC'
			return '7K' #Code for FCPIS
		elsif value == 'PG' or value == 'IE'
			return '70' #Code for GxG or EMI
		elsif value == 'BB'
			return '52' #Code for Bound Printed Matter
		elsif value == 'BL'
			return '54' #Code for Library Mail
		elsif value == 'BS'
			return '53' #Code for Media Mail
		elsif value == 'RP'
			return '5I' #Code for PRS
		elsif value == 'PS' or value == 'LW'
			return '5H' #Code for Parcel Select
		else
			return '50' #Package Services Default
		end
	end
	#*********************************************************************************************************************************
	#Determine Shape Value for STATS Samples, takes (Processing Category, Rate Indicator)
	def statsShape(pc, ri)
		if pc == '1'
			return '3' if ri == 'E3' or ri == 'E4' #Flat Rate Envelope
			return '1'  #Letters
		elsif pc == '2'
			return '3' if ri == 'E3' or ri == 'E4' or ri == 'FE' #Flat Rate Envelope
			return 'I' if ri == 'E5' or ri == 'E6' or ri == 'E7' #Legal Flat Rate Envelope
			return '9' if ri == 'FP' #Flat Rate Padded Envelope
			return '2'  #Flats
		elsif pc == '3'
			return 'J' if ri == 'C6'
			return 'K' if ri == 'C7'
			return 'L' if ri == 'C8'
			return '8' if ri == 'E8' or ri == 'E9' or ri == 'EE' #Regular/Medium Flat Rate Box
			return '5' #Parcels
		elsif pc == '4'
			return '5' #Parcels
		elsif pc == '5'
			return '9' if ri == 'FP' #Flat Rate Padded Envelope
			return 'F' if ri == 'FS' #Small Flat Rate Box
			return '8' if ri == 'FB' #Regular/Medium Flat Rate Box
			return 'D' if ri == 'PL' #Large Flat Rate Box
			return 'E' if ri == 'PM' #Large Flat Rate Military Box
			return '5' #Parcels
		elsif pc == 'O'
			return '7' #PMOD/Pallets
		else
			return '0' #Default/Fill
		end
	end
	#*********************************************************************************************************************************
	#Determine 'Marking' field value for STATS sample files
	def statsMarking(value)  #Currently only handles LW, the rest are defaulted to '00'
		if value == 'LW'
			return '36'
		else
			return '00'
		end
	end
	#*********************************************************************************************************************************
	#Builds out a STATS File Version 2
	def buildSTATSv2()
		lines = []
		details = pullDetails()
		count = 0
		mclass = ''
		
		details.each do |d| #d is each detail record in hash format
			count = count + 1
			pic = d['Tracking Number'].ljust(34, ' ')
			pounds, ounces = statsWeight(d['Weight'])
			classInfo = statsClass(d['Mail Class'])
			mclass = d['Mail Class']
			shape = statsShape(d['Processing Category'], d['Rate Indicator'])
			
			case d['Processing Category']
				when '3'
					mailable = '1' #Machinable
				when '5'
					mailable = '2' #Non-machinable
				else
					mailable = '0' #Default/Fill
			end
			
			length = statsSize(d['Length']).rjust(3, ' ')
			height = statsSize(d['Height']).rjust(2, ' ')
			width = statsSize(d['Width']).rjust(2, ' ')
			
			if @intClasses.include?(d['Mail Class'])
				zip = '     '
				countryType = '1' if d['Destination Country Code'] == 'CA'
				countryType = '1' if d['Destination Country Code'] != 'CA'
				countryCode = d['Destination Country Code']
			else
				zip = d['Destination ZIP Code']
				countryType = '0'
				countryCode = '  0'
			end
			
			sampleLine = "661204THDSN0#{@date}RESC#{@time}99901#{count.to_s.rjust(4, '0')} 0                    1#{pounds}#{ounces}#{classInfo}00#{shape}#{mailable}00000#{@originZIP}#{zip}#{length}#{height}#{width}01000#{countryType}    0#{@date}0000002000#{countryCode}#{' '.rjust(20, ' ')}000  #{' '.rjust(13, ' ')}#{@date}01        #{pic}00         000000000000100001000000000000000000000000#{' '.rjust(144, ' ')}000000#{' '.rjust(66, ' ')}"
			lines << sampleLine
		end
		statsFile = File.open("#{$targetPath}\\Generated EVS Files\\STATS_#{@date}#{@time}#{mclass}.DAT", 'w')
		lines.each do |line|
			statsFile.write("\n") if line != lines[0]
			statsFile.write(line)
		end
		statsSem = File.open("#{$targetPath}\\Generated EVS Files\\STATS_#{@date}#{@time}#{mclass}.sem", 'w')
		statsSem.close()
		puts "Built STATS sample (.DAT/.sem) for #{@mailClass}!"
	end
	#*********************************************************************************************************************************
	#Builds out a STATS File Version 1
	def buildSTATS()
		lines = []
		details = pullDetails()
		count = 0
		mclass = ''
		
		details.each do |d| #d is each detail record in hash format
			count = count + 1
			pic = d['Tracking Number'].ljust(34, ' ')
			pounds, ounces = statsWeight(d['Weight'])
			ounces = ounces.rjust(4, ' ')
			classInfo = statsClass(d['Mail Class'])
			mclass = d['Mail Class']
			shape = statsShape(d['Processing Category'], d['Rate Indicator'])
			length = statsSize(d['Length']).rjust(3, '0')
			height = statsSize(d['Height']).rjust(2, '0')
			width = statsSize(d['Width']).rjust(2, '0')
			marking = statsMarking(d['Mail Class'])
			
			if @intClasses.include?(d['Mail Class'])
				zip = '     '
				countryType = '1' if d['Destination Country Code'] == 'CA'
				countryType = '1' if d['Destination Country Code'] != 'CA'
				countryCode = d['Destination Country Code']
			else
				zip = d['Destination ZIP Code']
				countryType = '0'
				countryCode = '  0'
			end
			
			sampleLine = "#{@date}5405315#{count.to_s.rjust(4, ' ')}#{pounds}#{ounces}   1#{classInfo}#{shape}K000#{length}#{height}#{width}0100#{@originZIP}#{pic}1#{@mid}#{zip}01THDSN0#{@date}0000#{marking}   0"
			lines << sampleLine
		end
		statsFile = File.open("#{$targetPath}\\Generated EVS Files\\STATS_#{@date}#{@time}#{mclass}.DAT", 'w')
		lines.each do |line|
			statsFile.write("\n") if line != lines[0]
			statsFile.write(line)
		end
		statsSem = File.open("#{$targetPath}\\Generated EVS Files\\STATS_#{@date}#{@time}#{mclass}.sem", 'w')
		statsSem.close()
		puts "Built STATS sample (.DAT/.sem) for #{@mailClass}!"
	end
	#**********************************************
	#Builds out a PASS Sample
	def buildPASS()
		lines = []
		details = pullDetails()
		count = 0
		mclass = ''
		
		details.each do |d| #d is each detail record in hash format
			count = count + 1
			mclass = d['Mail Class']
			pic = d['Tracking Number'].ljust(34, ' ')
			weight = passWeight(d['Weight'])
			length = passSize(d['Length'])
			height = passSize(d['Height'])
			width = passSize(d['Width'])
			
			if length.to_f > 0
				cubic = 'Y'
			else
				cubic = 'N'
			end
			
			sampleLine = "661204,0000,#{d['Destination Rate Indicator']},#{@facilityZIP},#{@date},#{@time},#{pic},#{d['Destination ZIP Code']},#{mclass},Y,#{d['Rate Indicator']},#{weight},Y,#{length},#{height},#{width},00000,#{cubic},THDSN0,N"
			lines << sampleLine
		end
		passFile = File.open("#{$targetPath}\\Generated EVS Files\\TRP_P1EVS_OUT_#{@date}#{mclass}.pass", 'w')
		lines.each do |line|
			passFile.write("\n") if line != lines[0]
			passFile.write(line)
		end
		passSem = File.open("#{$targetPath}\\Generated EVS Files\\TRP_P1EVS_OUT_#{@date}#{mclass}.sem", 'w')
		passSem.close()
		puts "Built PASS sample (.pass/.sem) for #{@mailClass}!"
	end
	#**********************************************
	#Re-format weight for PASS Files
	def passWeight(value)
		wholeNum = value[1, 4] #Pulls the 2nd (A), 3rd (B), 4th (C) and 5th (D) digit from the format 0ABCDdddd where 'd' is the decimal portion of the eVS weight convention
		decimal = value[5, 4]  #Pulls the decimal portion
		return "#{wholeNum}.#{decimal}"
	end
	#*********************************************************************************************************************************
	#Re-format dimensions for PASS Files
	def passSize(value)
		wholeNum = value[1,2] #Pulls the whole number portion from 00 to 99 of the eVS dimension/size convention
		decimal = value[3, 2] #Pulls the decimal portion
		return "#{wholeNum}.#{decimal}"
	end
	#*********************************************************************************************************************************
	#Builds out a POS Sample
	def buildPOS()
		lines = []
		details = pullDetails()
		count = 0
		mclass = ''
		
		details.each do |d| #d is each detail record in hash format
			count = count + 1
			mclass = d['Mail Class']
			pic = d['Tracking Number'].ljust(34, ' ')
			weight = posWeight(d['Weight'])
				
			sampleLine = "#{pic},#{@date},#{weight},#{d['Destination ZIP Code']},THDSN0"
			lines << sampleLine
		end
		posFile = File.open("#{$targetPath}\\Generated EVS Files\\TRP_P1PRS_OUT_#{@date}#{mclass}.pos", 'w')
		lines.each do |line|
			posFile.write("\n") if line != lines[0]
			posFile.write(line)
		end
		posFile.close()
		posSem = File.open("#{$targetPath}\\Generated EVS Files\\TRP_P1PRS_OUT_#{@date}#{mclass}.sem", 'w')
		posSem.close()
		puts "Built POS sample (.pos/.sem) for #{@mailClass}!"
	end
	#**********************************************
	#Re-format weight for POS Files
	def posWeight(value)
		wholeNum = value[1, 4] #Pulls the 2nd (A), 3rd (B), 4th (C) and 5th (D) digit from the format 0ABCDdddd where 'd' is the decimal portion of the eVS weight convention
		decimal = value[5, 4]  #Pulls the decimal portion
		return "#{wholeNum}.#{decimal}"
	end
	#*********************************************************************************************************************************
	#Method to Handle Extracts
	def buildExtracts()
		puts "Would you like to build any extracts (mis-shipped, duplicate package, or un-manifested)? (Y/N)"
		prompt
		choice = gets.chomp.upcase
		if choice == 'Y'
			puts "Enter the number of the extract you would like to build:"
			puts "1) Mis-Shipped"
			puts "2) Duplicate Package"
			puts "3) Un-manifested"
			prompt
			extract = gets.chomp
			while not ['1','2','3'].include?(extract)
				puts "#{extract} is not a valid entry.  Please enter 1, 2, or 3."
				prompt
				extract = gets.chomp
			end
			
			extract = extract.to_i
			case extract
			when 1
				buildMisshipped()
			when 2
				buildDupPackage()
			when 3
				buildUnmanifested()
			end
		end
	end
	#*********************************************************************************************************************************
	#Mis-Shipped Extract Builder
	def buildMisshipped()
		dduDetails = []
		first = true
		details = pullDetails() #sample(5) #Limit extract to 5 records which are sampled at random.  Using all detail records would clutter the extract reports.
		details.each do |d|
			dduDetails << d if d['Destination Rate Indicator'] == 'D'
			puts "#{d['Tracking Number']} has DRI #{d['Destination Rate Indicator']}(should be 'D')." if d['Destination Rate Indicator'] == 'D'
		end
		puts dduDetails.size
		dduDetails = dduDetails.sample(5) if dduDetails.size > 5
		extractFile = File.open("#{$targetPath}\\Generated EVS Files\\PTSExtract_Misship#{@date}_#{@mailClass}.dat", 'w')
		dduDetails.each do |d|
			extractFile.write("\n") if not first
			extractFile.write("#{d['Tracking Number'][12,22]}#{' '.ljust(60, ' ')}#{rand(10000..99999)}#{' '.ljust(31, ' ')}15TEST-MISSHIPD PARCEL#{' '.ljust(20, ' ')}#{@date}#{Time.now.strftime('%H%M')}#{' '.ljust(28,' ')}")
			first = false
		end
		extractFile.close()
		extractSem = File.open("#{$targetPath}\\Generated EVS Files\\PTSArrival_Misship#{@date}_#{@mailClass}.sem", 'w')
		extractSem.close()
		puts "Built mis-shipped extract (.dat/.sem) for #{@mailClass}!"
	end
	#*********************************************************************************************************************************
	#Duplicate Package Extract Builder
	def buildDupPackage()
		details = pullDetails().sample(5) #Limit extract to 5 records which are sampled at random.  Using all detail records would clutter the extract reports.
		first = true
		extractFile = File.open("#{$targetPath}\\Generated EVS Files\\PTSExtractManDup#{@date}_#{@mailClass}.dat", 'w')
		details.each do |d|
			extractFile.write("\n") if not first
			extractFile.write("#{['01','16'].sample}#{@date}#{Time.now.strftime('%H%M')}#{d['Tracking Number']}#{@efn.ljust(34, ' ')}#{rand(10000..99999)}    #{@mid}")
			first = false
		end
		extractFile.close()
		extractSem = File.open("#{$targetPath}\\Generated EVS Files\\PTSExtractManDup#{@date}_#{@mailClass}.sem", 'w')
		extractSem.close()
		puts "Built duplicate package extract (.dat/.sem) for #{@mailClass}!"
	end
	#*********************************************************************************************************************************
	#Un-manifested Extract Builder
	def buildUnmanifested()
		stc = getBaseSTC(@mailClass)
		pic = picGen(stc)
		first = true
		extractFile = File.open("#{$targetPath}\\Generated EVS Files\\PTSExtractWkly-Unman#{@date}_#{@mailClass}.dat", 'w')
		5.times do
			extractFile.write("\n") if not first
			extractFile.write("#{pic[12,22]}#{' '.ljust(60, ' ')}#{rand(10000..99999)}#{' '.ljust(33, ' ')}UN-MANIFESTED PARCEL RECORD#{' '.ljust(13, ' ')}#{@date}#{Time.now.strftime('%H%M')}#{' '.ljust(28, ' ')}")
			first = false
		end
		extractFile.close()
		extractSem = File.open("#{$targetPath}\\Generated EVS Files\\PTSArrivalWkly-Unman#{@date}_#{@mailClass}.sem", 'w')
		extractSem.close()
		puts "Built un-manifested extract (.dat/.sem) for #{@mailClass}!"
	end
	#*********************************************************************************************************************************
=end
	end
end

class Array
	def simplest()
		simplestObject = self.first #Set a starting point.
		self.each do |object|
			simplestObject = object if object.instance_variables.size < simplestObject.instance_variables.size
		end
		return simplestObject
	end
	
	def list() #Prints a formatted, easily readable list of collections containing either detail records, STCs, and rates.
		self.each_with_index do |object, index|
			objSummary = "#{object.class}"
			object.instance_variables.each do |var|
				objSummary = objSummary + " || " + object.send(var.to_s.delete('@'))
			end
			puts objSummary
		end
	end
end

#*********************************************************************************************************************************

class String
	def domestic? #If the 2-character mail class code is not in the below list of International mail classes, then it is domestic (return true) -- otherwise, false.
		!['LC', 'CP', 'PG', 'IE'].include?(self.chomp.upcase)
	end
end